# Time Profiler Visualizer
A minimalist C++ library for time profiling and a companion
appImage to visualise the elapsed time data generated by the labrary.

[![sample.png](https://i.postimg.cc/vZXRSjZ1/sample.png)](https://postimg.cc/Bj8wjmDs)

## Motivation

When profiling elapsed time of an application or part of an application,
we usually end repeating the test multiple times and comparing the resulting
data visually.

This library will keep track of the elapsed time and output a .js file
that can be loaded by [Time Profiler Visualizer](https://github.com/volatilflerovium/time_profiler_visualizer/releases)
to plot the samples in a line chart.

## AppImage

Time Profiler Visualizer is available as an AppImage ([in Releases](https://github.com/volatilflerovium/time_profiler_visualizer/releases)) 
which means "one app = one file", which you can download and run on your
Linux system while you don't need a package manager and nothing gets changed
in your system.

AppImages are single-file applications that run on most Linux distributions.
Download it, make it executable, and run! No need to install.
No system libraries or system preferences are altered.
Most AppImages run on recent versions of Arch Linux, CentOS, Debian, Fedora,
openSUSE, Red Hat, Ubuntu, and other common desktop distributions.

### Desktop Integration

Creating a desktop entries for Time Profiler Visualizer ensures quick access
from the Application menu. 

Time Profiler Visualizer can autoinstall itself. When running the appImage, 
clink on the Documentation button an follow the instructions.

## Example

```
  profiler::TimeProfiler<std::chrono::microseconds> timeProfiler("someName", "#colour").
  
  //example 1)
  
  
  	//do something
  
    timeProfiler.start()
    // do task to profile
    timeProfiler.takeSample(true)    // here we capture individual samples
   
    // do more stuff
  

  //example 2)
  
  // do something
  
  timeProfiler.start()
  // do some task to profile 
  timeProfiler.pause()    // here we pause the clock
   
  // do more stuff

  timeProfiler.start()
  // do another task to profile 
  timeProfiler.pause()    // here we pause the clock
   
  timeProfiler.takeAverageSample(); // here we capture the average of the elapsed time 
  
```


## Custom time periods


```
 namespace tprofiler	
 {
 	struct FramePerSecond
 	{};
 
 	template<>
 	struct TimeType<FramePerSecond>
 	{
 		static constexpr const char* timeUnit="fps";
 		typedef std::ratio<1, 24> timePeriod;
 	};
 }

 ...
 tprofiler::TimeProfiler<tprofiler::FramePerSecond> watch("easyjson_one", "#9bddff", "/tmp");
 ...
```

Another example:

```
 namespace tprofiler	
 {
 	struct Every10Mins
 	{};
 
 	template<>
 	struct TimeType<Every10Mins>
 	{
 		static constexpr const char* timeUnit="10Ms";
 		typedef std::ratio<600> timePeriod;
 	};
 }

 ...
 using 10MinProfiler=tprofiler::TimeProfiler<tprofiler::Every10Mins>;
 
 10MinProfiler watchEvery10("easyjson_one", "#9bddff", "/tmp");
 ...
```
